{"version":3,"file":"microbin.1.0.0.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,uDAAuD;AACvD;AACA;AACA;AACA,iBAAiB,oGAAoG,cAAc;AACnI,8BAA8B,sBAAsB;AACpD,0BAA0B,YAAY,sBAAsB,qCAAqC,2CAA2C,MAAM;AAClJ,4BAA4B,MAAM,iBAAiB,YAAY;AAC/D,uBAAuB;AACvB,8BAA8B;AAC9B,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,gBAAgB,GAAG,YAAY,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,aAAa;AACxG,eAAe,mBAAO,CAAC,6BAAQ;AAC/B,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,aAAa,mBAAO,CAAC,iCAAU;AAC/B,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uFAAuF,yCAAyC;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,oFAAoF,yCAAyC;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA,eAAe;;;;;;;;;;;ACpIF;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,yBAAyB,GAAG,cAAc,GAAG,gBAAgB,GAAG,mBAAmB;AAClH,eAAe,mBAAO,CAAC,6BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B;;;;;;;;;;;ACxNf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,aAAa,GAAG,qBAAqB;AACpD,qBAAqB;AACrB,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA,cAAc;;;;;;;UCLd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://microbin/webpack/universalModuleDefinition","webpack://microbin/./src/index.ts","webpack://microbin/./src/reader.ts","webpack://microbin/./src/type.ts","webpack://microbin/./src/writer.ts","webpack://microbin/webpack/bootstrap","webpack://microbin/webpack/before-startup","webpack://microbin/webpack/startup","webpack://microbin/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"microbin\"] = factory();\n\telse\n\t\troot[\"microbin\"] = factory();\n})(self, () => {\nreturn ","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadAll = exports.loadIter = exports.load = exports.loadsAll = exports.loadsIter = exports.loads = void 0;\nconst type_1 = require(\"./type\");\nconst reader_1 = require(\"./reader\");\n__exportStar(require(\"./type\"), exports);\n__exportStar(require(\"./reader\"), exports);\n__exportStar(require(\"./writer\"), exports);\nfunction loads(data, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const reader = yield (0, reader_1.ArrayBufferReader)(data, allowedMagic);\n        if (reader.count !== 1)\n            throw new reader_1.DecodeError(\"File contains more than one global object\");\n        return yield reader.read();\n    });\n}\nexports.loads = loads;\nfunction loadsIter(data, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __asyncGenerator(this, arguments, function* loadsIter_1() {\n        const reader = yield __await((0, reader_1.ArrayBufferReader)(data, allowedMagic));\n        for (let i = 0; i < reader.count; i++) {\n            yield yield __await(yield __await(reader.read()));\n        }\n    });\n}\nexports.loadsIter = loadsIter;\nfunction loadsAll(data, allowedMagic = type_1.DEFAULT_MAGIC) {\n    var _a, e_1, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n        const arr = [];\n        try {\n            for (var _d = true, _e = __asyncValues(loadsIter(data, allowedMagic)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const i = _c;\n                arr.push(i);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return arr;\n    });\n}\nexports.loadsAll = loadsAll;\nfunction load(fp, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const reader = yield (0, reader_1.ReadableStreamReader)(fp, allowedMagic);\n        if (reader.count !== 1)\n            throw new reader_1.DecodeError(\"File contains more than one global object\");\n        return yield reader.read();\n    });\n}\nexports.load = load;\nfunction loadIter(fp, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __asyncGenerator(this, arguments, function* loadIter_1() {\n        const reader = yield __await((0, reader_1.ReadableStreamReader)(fp, allowedMagic));\n        for (let i = 0; i < reader.count; i++) {\n            yield yield __await(yield __await(reader.read()));\n        }\n    });\n}\nexports.loadIter = loadIter;\nfunction loadAll(fp, allowedMagic = type_1.DEFAULT_MAGIC) {\n    var _a, e_2, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n        const arr = [];\n        try {\n            for (var _d = true, _e = __asyncValues(loadIter(fp, allowedMagic)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                _c = _f.value;\n                _d = false;\n                const i = _c;\n                arr.push(i);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return arr;\n    });\n}\nexports.loadAll = loadAll;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Reader_instances, _Reader_count, _Reader_flags, _Reader_allowedMagic, _Reader_chunk, _Reader_offset, _Reader_read, _Reader_readObjectHeader;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableStreamReader = exports.ArrayBufferReader = exports.Reader = exports.EOFError = exports.DecodeError = void 0;\nconst type_1 = require(\"./type\");\nclass DecodeError extends Error {\n    constructor(msg) {\n        super(msg);\n    }\n}\nexports.DecodeError = DecodeError;\nclass EOFError extends DecodeError {\n    constructor() {\n        super(\"End of file\");\n    }\n}\nexports.EOFError = EOFError;\nclass Reader {\n    constructor(feeder, allowedMagic = type_1.DEFAULT_MAGIC) {\n        _Reader_instances.add(this);\n        _Reader_count.set(this, 0);\n        _Reader_flags.set(this, 0);\n        _Reader_allowedMagic.set(this, void 0);\n        _Reader_chunk.set(this, undefined);\n        _Reader_offset.set(this, 0);\n        if (typeof allowedMagic === \"number\")\n            allowedMagic = [allowedMagic];\n        __classPrivateFieldSet(this, _Reader_allowedMagic, allowedMagic, \"f\");\n        this.feeder = feeder;\n    }\n    readHeader() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, 8);\n            if (data.getUint16(0) !== 0x6D62)\n                throw new DecodeError(\"Invalid magic bytes\");\n            if (!__classPrivateFieldGet(this, _Reader_allowedMagic, \"f\").includes(data.getUint16(2)))\n                throw new DecodeError(\"Invalid application magic bytes\");\n            if (data.getUint8(4) !== 0)\n                throw new DecodeError(\"Unsupported version\");\n            __classPrivateFieldSet(this, _Reader_flags, data.getUint8(5), \"f\");\n            __classPrivateFieldSet(this, _Reader_count, data.getUint16(6), \"f\");\n        });\n    }\n    get count() {\n        return __classPrivateFieldGet(this, _Reader_count, \"f\");\n    }\n    get flags() {\n        return __classPrivateFieldGet(this, _Reader_flags, \"f\");\n    }\n    read(_globl = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { type, value } = yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_readObjectHeader).call(this, _globl);\n            switch (type) {\n                case type_1.Type.NONE: return null;\n                case type_1.Type.FALSE: return false;\n                case type_1.Type.TRUE: return true;\n                case type_1.Type.FLOAT16:\n                    return (yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, 2)).getFloat32(0);\n                case type_1.Type.FLOAT32:\n                    return (yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, 4)).getFloat32(0);\n                case type_1.Type.FLOAT64:\n                    return (yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, 8)).getFloat64(0);\n                case type_1.Type.RATIONAL:\n                    throw new Error(\"Not implemented!\");\n                case type_1.Type.INT: return value;\n                case type_1.Type.NINT: return -value;\n                case type_1.Type.STRING: {\n                    const data = yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, value);\n                    const decoder = new TextDecoder(\"utf-8\");\n                    return decoder.decode(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n                }\n                case type_1.Type.BYTES: {\n                    const data = yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, value);\n                    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n                }\n                case type_1.Type.LIST: {\n                    const res = [];\n                    for (let i = 0; i < value; i++) {\n                        res.push(yield this.read(false));\n                    }\n                    return res;\n                }\n                case type_1.Type.MAP: {\n                    const res = Object.create(null);\n                    for (let i = 0; i < value; i++) {\n                        const k = yield this.read(false);\n                        res[k] = yield this.read(false);\n                    }\n                    return res;\n                }\n                default:\n                    throw new Error(\"Internal error! Please, report a bug.\");\n            }\n        });\n    }\n}\nexports.Reader = Reader;\n_Reader_count = new WeakMap(), _Reader_flags = new WeakMap(), _Reader_allowedMagic = new WeakMap(), _Reader_chunk = new WeakMap(), _Reader_offset = new WeakMap(), _Reader_instances = new WeakSet(), _Reader_read = function _Reader_read(n) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof n != \"number\")\n            throw new DecodeError(\"64-bit offsets not supported\");\n        while (__classPrivateFieldGet(this, _Reader_chunk, \"f\") === undefined || __classPrivateFieldGet(this, _Reader_offset, \"f\") + n > __classPrivateFieldGet(this, _Reader_chunk, \"f\").byteLength) {\n            const { done, value } = yield this.feeder();\n            if (done)\n                throw new EOFError();\n            if (value === undefined)\n                continue;\n            if (__classPrivateFieldGet(this, _Reader_chunk, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _Reader_chunk, value, \"f\");\n                __classPrivateFieldSet(this, _Reader_offset, 0, \"f\");\n                continue;\n            }\n            const l = __classPrivateFieldGet(this, _Reader_chunk, \"f\").byteLength - __classPrivateFieldGet(this, _Reader_offset, \"f\");\n            const chunk = new Uint8Array(l + value.byteLength);\n            chunk.set(__classPrivateFieldGet(this, _Reader_chunk, \"f\").slice(__classPrivateFieldGet(this, _Reader_offset, \"f\")));\n            chunk.set(value, l);\n            __classPrivateFieldSet(this, _Reader_chunk, chunk, \"f\");\n            __classPrivateFieldSet(this, _Reader_offset, 0, \"f\");\n        }\n        const offset = __classPrivateFieldGet(this, _Reader_offset, \"f\");\n        __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, \"f\") + n, \"f\");\n        return new DataView(__classPrivateFieldGet(this, _Reader_chunk, \"f\").buffer, __classPrivateFieldGet(this, _Reader_chunk, \"f\").byteOffset + offset, n);\n    });\n}, _Reader_readObjectHeader = function _Reader_readObjectHeader(globl) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        if (globl) {\n            if (!__classPrivateFieldGet(this, _Reader_count, \"f\"))\n                throw new EOFError();\n            __classPrivateFieldSet(this, _Reader_count, (_a = __classPrivateFieldGet(this, _Reader_count, \"f\"), _a--, _a), \"f\");\n        }\n        let t = (yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, 1)).getUint8(0);\n        let tag = t >> 5;\n        t &= 0b11111;\n        let i = 0;\n        while (i != 5 && t & (1 << (4 - i))) {\n            i++;\n        }\n        t &= (1 << (5 - i)) - 1;\n        if (i == 5)\n            i = 8;\n        let data = yield __classPrivateFieldGet(this, _Reader_instances, \"m\", _Reader_read).call(this, i);\n        if (i == 8) {\n            return {\n                type: tag,\n                value: (BigInt(t) << BigInt(i * 8)) | data.getBigUint64(0)\n            };\n        }\n        t <<= i * 8;\n        switch (i) {\n            case 0: break;\n            case 1:\n                t |= data.getUint8(0);\n                break;\n            case 2:\n                t |= data.getUint16(0);\n                break;\n            case 3:\n                t |= (data.getUint8(0) << 16) | data.getUint16(1);\n                break;\n            case 4:\n                t |= data.getUint32(0);\n                break;\n        }\n        if (tag === type_1.Type.SPECIAL) {\n            tag = (1 << 4) | t;\n            t = 0;\n        }\n        return {\n            type: tag,\n            value: t\n        };\n    });\n};\nfunction ArrayBufferReader(data, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let done = false;\n        const reader = new Reader(() => __awaiter(this, void 0, void 0, function* () {\n            if (done)\n                return { done, value: undefined };\n            done = true;\n            return { done: false, value: new Uint8Array(data) };\n        }), allowedMagic);\n        yield reader.readHeader();\n        return reader;\n    });\n}\nexports.ArrayBufferReader = ArrayBufferReader;\nfunction ReadableStreamReader(fp, allowedMagic = type_1.DEFAULT_MAGIC) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const streamReader = fp.getReader();\n        const reader = new Reader(() => streamReader.read(), allowedMagic);\n        yield reader.readHeader();\n        return reader;\n    });\n}\nexports.ReadableStreamReader = ReadableStreamReader;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Type = exports.Flags = exports.DEFAULT_MAGIC = void 0;\nexports.DEFAULT_MAGIC = 0x0000;\nexports.Flags = {};\nexports.Type = {\n    SPECIAL: 0b000, //\n    RATIONAL: 0b001, //\n    INT: 0b100, // inline, max 64\n    NINT: 0b010, // inline, max 64\n    STRING: 0b011, // sized, inline\n    BYTES: 0b101, // sized, inline\n    LIST: 0b110, // sized\n    MAP: 0b111, // sized\n    NONE: 16, // singleton\n    FALSE: 17, // singleton\n    TRUE: 18, // singleton\n    FLOAT16: 19, // 2 bytes\n    FLOAT32: 20, // 4 bytes\n    FLOAT64: 21, // 8 bytes\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Writer = void 0;\nclass Writer {\n}\nexports.Writer = Writer;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}